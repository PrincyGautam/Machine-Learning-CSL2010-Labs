# -*- coding: utf-8 -*-
"""B20BB051.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZR6zJim-vRIE1MAtu1d-IoPVMG3GCH2E
"""

import numpy as np
import pandas as pd
import math
import random
import csv
df = pd.read_csv("/content/diabetes.csv")
df.head()

from sklearn.preprocessing import StandardScaler
sc_X = StandardScaler()
df1 = df.drop(["Outcome"],axis = 1)
X =  pd.DataFrame(sc_X.fit_transform(df1),columns=['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin','BMI', 'DiabetesPedigreeFunction', 'Age'])
Y = df.Outcome
X.head()

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.3,random_state=25)
print("Train:", x_train.shape[0])
print("Test:", x_test.shape[0])

from sklearn.naive_bayes import GaussianNB
model = GaussianNB()
model.fit(x_train, y_train)
predicted = model.predict(x_test)

from sklearn import metrics
print("Accuracy:",metrics.accuracy_score(y_test, predicted)*100)

def split(mydata, ratio):
	train_num = int(len(mydata) * ratio)
	train = []
	test = list(mydata)
	while len(train) < train_num:
		index = random.randrange(len(test))
		train.append(test.pop(index))
	return train, test

def groupUnderClass(mydata):
	dict = {}
	for i in range(len(mydata)):
		if (mydata[i][-1] not in dict):
			dict[mydata[i][-1]] = []
		dict[mydata[i][-1]].append(mydata[i])
	return dict

def mean(numbers):
	return sum(numbers) / float(len(numbers))

def std_deviation(numbers):
	avg = mean(numbers)
	variance = sum([pow(x - avg, 2) for x in numbers]) / float(len(numbers) - 1)
	return math.sqrt(variance)

def mean_and_std_deviation(mydata):
	info = [(mean(attribute), std_deviation(attribute)) for attribute in zip(*mydata)]
	del info[-1]
	return info

def MeanAndStdDevForClass(mydata):
	info = {}
	dict = groupUnderClass(mydata)
	for classValue, instances in dict.items():
		info[classValue] = mean_and_std_deviation(instances)
	return info

def gaussian_proba(x, mean, stdev):
	expo = math.exp(-(math.pow(x - mean, 2) / (2 * math.pow(stdev, 2))))
	return (1 / (math.sqrt(2 * math.pi) * stdev)) * expo


def class_proba(info, test):
	probabilities = {}
	for classValue, classSummaries in info.items():
		probabilities[classValue] = 1
		for i in range(len(classSummaries)):
			mean, std_deviation = classSummaries[i]
			x = test[i]
			probabilities[classValue] *= gaussian_proba(x, mean, std_deviation)
	return probabilities

def predict(info, test):
	probabilities = class_proba(info, test)
	bestLabel, bestProb = None, -1
	for classValue, probability in probabilities.items():
		if bestLabel is None or probability > bestProb:
			bestProb = probability
			bestLabel = classValue
	return bestLabel

def obtain_pred(info, test):
	predictions = []
	for i in range(len(test)):
		result = predict(info, test[i])
		predictions.append(result)
	return predictions

def accuracy(test, predictions):
	correct = 0
	for i in range(len(test)):
		if test[i][-1] == predictions[i]:
			correct += 1
	return (correct / float(len(test))) * 100.0


# driver code
filename = r'/content/diabetes.csv'
mydata =csv.reader(open(filename, "r"))
next(mydata)
mydata = list(mydata)
mydata = encode_class(mydata)
for i in range(len(mydata)):
	mydata[i] = [float(x) for x in mydata[i]]

ratio = 0.7
train_data, test_data = split(mydata, ratio)
print('Total number of examples | ', len(mydata))
print('Training examples | ', len(train_data))
print("Test examples | ", len(test_data))

info = MeanAndStdDevForClass(train_data)

predictions = obtain_pred(info, test_data)
accuracy = accuracy(test_data, predictions)
print("Accuracy of model from scratch |", accuracy)

X['Pregnancies'].hist()

X.hist()