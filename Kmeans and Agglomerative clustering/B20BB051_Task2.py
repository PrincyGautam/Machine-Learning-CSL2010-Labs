# -*- coding: utf-8 -*-
"""B20BB051_Task 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mImmS6ErhVmqGkTX8oil9tXnNHh321zA
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as pltlb
from sklearn import preprocessing
df = pd.read_csv('/content/milk.csv')
D = df.drop(df.columns[0],axis=1)
D = np.array(D)

df.drop(df.columns[0],axis=1)

import scipy.cluster.hierarchy as shc

pltlb.figure(figsize=(10, 7))
pltlb.title('Milk Dendogram')
pltlb.grid()
dend = shc.dendrogram(shc.linkage(D, method='ward'))

from sklearn.cluster import AgglomerativeClustering

cluster1 = AgglomerativeClustering(n_clusters=2, affinity='euclidean', linkage='ward')
pltlb.figure(figsize=(10, 7))
pltlb.grid()
pltlb.scatter(D[:,1],D[:,4], s=150, c=cluster1.fit_predict(D) , cmap='cividis')

cluster2 = AgglomerativeClustering(n_clusters=5, affinity='euclidean', linkage='average')
pltlb.figure(figsize=(10, 7))
pltlb.grid()
pltlb.scatter(D[:,1],D[:,4], s=150, c=cluster2.fit_predict(D) , cmap='cividis')

cluster3 = AgglomerativeClustering(n_clusters=4, affinity='euclidean', linkage='single')
pltlb.figure(figsize=(10, 7))
pltlb.grid()
pltlb.scatter(D[:,1],D[:,4], s=150, c=cluster3.fit_predict(D) , cmap='cividis')

class KMeansClustering:
    def __init__(self, D, num_clusters):
        self.K = num_clusters
        self.max_iterations = 200
        self.num_examples, self.num_features = D.shape 
        self.plot_figure = True


    def initialize_random_centroids(self, D):
        centroids = np.zeros((self.K, self.num_features)) 
        for k in range(self.K): 
            centroid = D[np.random.choice(range(self.num_examples))] 
            centroids[k] = centroid
        return centroids
    

    def create_cluster(self, D, centroids):
        clusters = [[] for i in range(self.K)]
        for point_index, point in enumerate(D):
            closest_centroid = np.argmin(np.sqrt(np.sum((point-centroids)**2, axis=1))) 
            clusters[closest_centroid].append(point_index)
        return clusters 
    

    def calculate_new_centroids(self, cluster, D):
        centroids = np.zeros((self.K, self.num_features)) 
        for index, cluster in enumerate(cluster):
            new_centroid = np.mean(D[cluster], axis=0)
            centroids[index] = new_centroid
        return centroids
    

    def predict_cluster(self, clusters, D):
        y_pred = np.zeros(self.num_examples) 
        for cluster_index, cluster in enumerate(clusters):
            for sample_index in cluster:
                y_pred[sample_index] = cluster_index
        return y_pred
    

    def plot_fig(self, D, r):
      pltlb.figure(figsize=(10, 7))
      pltlb.scatter(D[:, 1], D[:, 4], s=160, marker='o', c=r)
      pltlb.grid()
      pltlb.show()


    def fit(self, D):
        centroids = self.initialize_random_centroids(D) 
        for i in range(self.max_iterations):
            clusters = self.create_cluster(D, centroids) 
            previous_centroids = centroids
            centroids = self.calculate_new_centroids(clusters, D)
            diff = centroids - previous_centroids 
            if not diff.any():
                break
        y_pred = self.predict_cluster(clusters, D) 
        if self.plot_figure:
            self.plot_fig(D, y_pred) 
        return y_pred
            
if __name__ == "__main__":
    num_clusters = 2 
    Kmeans = KMeansClustering(D, num_clusters)
    y_pred = Kmeans.fit(D)